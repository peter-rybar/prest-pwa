{"version":3,"file":null,"sources":["../src/main/sw.ts"],"sourcesContent":["// https://codelabs.developers.google.com/codelabs/workbox-lab/\n\ndeclare const importScripts: (script: string) => void;\ndeclare const WorkboxSW: any;\n\nimportScripts(\"lib/workbox-sw.js\");\n// importScripts(\"./node_modules/workbox-sw/build/importScripts/workbox-sw.prod.v2.1.1.js\");\n// importScripts(\"https://unpkg.com/workbox-sw@2.0.3/build/importScripts/workbox-sw.dev.v2.0.3.js\");\n\n/**\n * Create an instance of WorkboxSW.\n * Setting clientsClaims to true tells our service worker to take control as\n * soon as it's activated.\n */\nconst workboxSW = new WorkboxSW({clientsClaim: true});\n\n/**\n * precache() is passed a manifest of URLs and versions, and does the following\n * each time the service worker starts up:\n *   - Adds all new URLs to a cache.\n *   - Refreshes the previously cached response if the URL isn't new, but the\n *     revision changes. This will also trigger a Broadcast Channel API message\n *     sent to the channel 'precache-updates'.\n *   - Removes entries for URLs that used to be in the list, but aren't anymore.\n *   - Sets up a fetch handler to respond to any requests for URLs in this\n *     list using a cache-first strategy.\n *\n * DO NOT CREATE OR UPDATE THIS LIST BY HAND!\n * Instead, add one of our tools (workbox-cli, workbox-webpack-plugin, or\n * workbox-build) to your existing build process, and have that regenerate the\n * manifest at the end of every build.\n */\nworkboxSW.precache([]);\n\n/**\n * registerNavigationRoute() is used for sites that follow the App Shell Model,\n * https://developers.google.com/web/fundamentals/architecture/app-shell\n * It tells the service worker that whenever there's a navigation request for\n * a new URL, instead of returning the HTML for that URL, return a previously\n * cached \"shell\" HTML file instead.\n *\n * If you want more control over which navigations use the \"shell\" HTML, you\n * can provide an optional array of regular expressions:\n *   - whitelist (which defaults to [/./])\n *   - blacklist (which defaults to [])\n *\n * (For the purposes of this demo, which doesn't follow the App Shell Model,\n * registerNavigationRoute() is commented out.)\n */\n// workboxSW.router.registerNavigationRoute('app-shell.html', {\n//     whitelist: [/./],\n//     blacklist: [],\n// });\n\n/**\n * Requests for URLs that aren't precached can be handled by runtime caching.\n * Workbox has a flexible routing system, giving you control over which caching\n * strategies to use for which kind of requests.\n *\n * registerRoute() takes a RegExp or a string as its first parameter.\n *   - RegExps can match any part of the request URL.\n *   - Strings are Express-style routes, parsed by\n *     https://github.com/nightwolfz/path-to-regexp\n *\n * registerRoute() takes a caching strategy as its second parameter.\n * The built-in strategies are:\n *   - cacheFirst\n *   - cacheOnly\n *   - networkFirst\n *   - networkOnly\n *   - staleWhileRevalidate\n * Advice about which strategies to use for various assets can be found at\n * https://developers.google.com/web/fundamentals/instant-and-offline/offline-cookbook/\n *\n * Each strategy can be configured with additional options, controlling the\n * name of the cache that's used, cache expiration policies, which response\n * codes are considered valid (useful when you want to cache opaque responses)\n * and whether updates to previously cached responses should trigger a message\n * using the BroadcastChannel API.\n *\n * The following routes show this flexibility put to use.\n */\n\n/**\n * Set up a route that will match any URL requested that ends in .txt.\n * Handle those requests using a network-first strategy.\n */\n// workboxSW.router.registerRoute(\n//     /\\.txt$/,\n//     workboxSW.strategies.networkFirst()\n// );\n\n/**\n * Set up a route that will match any URL requested that starts with\n * https://httpbin.org/delay/.\n * Handle those requests using a network-first strategy, but with a timeout.\n * If there's no network response before the timeout, then return the previous\n * response from the cache instead.\n */\n// workboxSW.router.registerRoute(\n//     \"https://httpbin.org/delay/(.*)\",\n//     workboxSW.strategies.networkFirst({networkTimeoutSeconds: 3})\n// );\n\n/**\n * Set up a route that will match any URL requested that starts with\n * https://httpbin.org/image/.\n * Handle those requests using a cache-first strategy, storing them in a\n * dedicated cache named 'images'.\n * That cache has a maximum size of 2 entries,\n * and once that's reached, the least-recently used entry will be deleted.\n * Additionally, any entries older than 7 * 24 * 60 * 60 seconds (1 week) will\n * be deleted.\n * Because the image responses are cross-domain and don't use CORS, they will\n * be \"opaque\", and have a status code of 0. When using a cache-first strategy,\n * we need to explicitly opt-in to caching responses with a status of 0.\n */\n// workboxSW.router.registerRoute(\n//     \"https://httpbin.org/image/(.*)\",\n//     workboxSW.strategies.cacheFirst({\n//         cacheName: \"images\",\n//         cacheExpiration: {\n//         maxEntries: 2,\n//         maxAgeSeconds: 7 * 24 * 60 * 60,\n//         },\n//         cacheableResponse: {statuses: [0, 200]},\n//     })\n// );\n"],"names":["importScripts","WorkboxSW","clientsClaim","precache"],"mappings":"sJAKAA,eAAc,qBASI,GAAIC,YAAWC,cAAc,IAkBrCC"}